<!doctype html>
<html>
	<head>
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<style>
			* {
				padding: 0; margin: 0;
				box-sizing: border-box;
			}
			html {
				height: 100%;
			}
			body {
				height: 100%;
				display: flex;
				justify-content: center;
				background: black;
			}
			canvas {
				border: solid 1px black;
			}
		</style>
	</head>
	<body>
		<canvas id="main"></canvas>
	</body>
	<script>
		const WIDTH = document.body.offsetHeight; const HEIGHT = document.body.offsetHeight;
		const MAXTURN = Math.PI*4/18

		main = {
			start: function(){
				this.canvas = document.getElementById("main");
				this.canvas.width = WIDTH; this.canvas.height = HEIGHT;
				this.ctx = this.canvas.getContext("2d")
				this.loop = setInterval(mainloop,20)
			}
		}

		player = {
			pos: [200,500], face: 0,
			steerRot: 0, steerMax: Math.PI*7/36,
			steerDirection: 0,
			speed: 0, maxSpeed: 8,
			targetIndex: 0,
			tPos: [800,800], tFace: 0,
			move: function(){
				this.updateSteer()
				this.tPos = target[this.targetIndex].pos
				this.checkPos()
				this.updateSpeed()
				this.updatePos()
				//console.log(this.steerDirection)
				//this.speed = 0
			},
			checkPos: function(){
				check = Math.sqrt((this.pos[0]-this.tPos[0])**2+(this.pos[1]-this.tPos[1])**2)
				return check > 50;
			},
			steer: function(){
				if (this.steerDirection){
					if ((this.steerRot < this.steerMax && this.steerDirection > 0) || (this.steerRot > -this.steerMax && this.steerDirection < 0)){
						this.steerRot += Math.PI/(60+30*Math.exp(-3*Math.abs(this.steerRot)/MAXTURN)) * this.steerDirection
					}
				} else {
					if (Math.abs(this.steerRot) > 2*10**-2){
						this.steerRot -= Math.PI/90 * this.steerRot/Math.abs(this.steerRot)
					} else {
						this.steerRot = 0
					}
				}

			},
			updateSteer: function(){
				dy = this.tPos[1]-this.pos[1]; dx = this.tPos[0]-this.pos[0];
				if (dx == 0){
					if (dy!=0){
						slope = -Infinity
					} else {
						slope = Infinity
					}
				} else {
					slope = (dy)/(dx)
					slope = Math.atan(slope)
					if (dx < 0){
						slope = Math.PI + slope
					} else if (dy < 0){
						slope = 2*Math.PI + slope
					}
				}

				//console.log(dx+","+dy)
				/*
				main.ctx.beginPath()
				main.ctx.moveTo((this.pos[0]/1000)*HEIGHT-100*Math.cos(slope),(this.pos[1]/1000)*HEIGHT-100*Math.sin(slope))
				main.ctx.lineTo((this.pos[0]/1000)*HEIGHT+100*Math.cos(slope),(this.pos[1]/1000)*HEIGHT+100*Math.sin(slope))
				main.ctx.lineTo((this.pos[0]/1000)*HEIGHT+90*Math.cos(slope+Math.PI/45),(this.pos[1]/1000)*HEIGHT+90*Math.sin(slope+Math.PI/45))
				main.ctx.strokeStyle = "red"
				main.ctx.stroke()*/

				if (this.face > 2*Math.PI){
					this.face = this.face%(2*Math.PI)
				} else if (this.face < 0){
					this.face = 2*Math.PI - this.face
				}

				angle = Math.abs(slope+2*Math.PI-(this.face%(Math.PI*2)))%(2*Math.PI)

				if (angle > Math.PI){
					angle = angle - 2*Math.PI
					this.steerDirection = -1
				} else if(angle < Math.PI){
					this.steerDirection = 1
				} else {
					this.steerDirection = 0
				}
				//console.log(angle)
				this.steerMax = MAXTURN - MAXTURN*Math.exp(-1*2*(Math.abs(angle)/Math.PI))


				turn = (720/(10-10*Math.exp(-this.speed)))
				this.steer()
			},
			updateSpeed: function(){
				okay = this.checkPos()
				if (this.speed < this.maxSpeed && okay){
					this.speed = (this.speed*100+5)/100
				} else if (!okay){
					this.targetIndex = Math.floor(Math.random()*target.length)
				}
				if (this.speed > 0 && okay){
					this.speed = (this.speed*100-12*Math.abs(this.steerRot)*(1-Math.exp(-(this.maxSpeed/2)*this.speed/this.maxSpeed))/MAXTURN)/100
				} else if (this.speed < 8 && okay){
					this.speed = (this.speed*100+3)/100
				} else if (this.speed > 0 && !okay){
					this.speed = (this.speed*10-3)/10
				} else if (this.speed < 0){
					this.speed = 0
				}
				//console.log(this.speed)
				this.face += this.steerRot*this.speed/40

				/*
				dy = this.tPos[1]-this.pos[1]; dx = this.tPos[0]-this.pos[0];
				if (dx == 0){
					if (dy!=0){
						slope = -Infinity
					} else {
						slope = Infinity
					}
				} else {
					slope = (dy)/(dx)
					slope = Math.atan(slope)
					if (dx < 0){
						slope = Math.PI + slope
					} else if (dy < 0){
						slope = 2*Math.PI + slope
					}
				} 
				if (this.face > 2*Math.PI){
					this.face = this.face%(2*Math.PI)
				} else if (this.face < 0){
					this.face = 2*Math.PI - this.face
				}
				angle = Math.abs(slope+2*Math.PI-(this.face%(Math.PI*2)))%(2*Math.PI)
				turn = (720/(10-10*Math.exp(-this.speed)))
				console.log(10-10*Math.exp(-this.speed))

				if (Math.PI > angle){
					this.face = (this.face*1000 + (Math.PI/turn)*1000)/1000
				} else {
					this.face = (this.face*1000 - (Math.PI/turn)*1000)/1000
				}*/
				//console.log(dy+"/"+dx+" = "+slope)
				//console.log(this.face%2*Math.PI)
				/*
				main.ctx.beginPath()
				main.ctx.moveTo((this.pos[0]/1000)*HEIGHT-100*Math.cos(slope),(this.pos[1]/1000)*HEIGHT-100*Math.sin(slope))
				main.ctx.lineTo((this.pos[0]/1000)*HEIGHT+100*Math.cos(slope),(this.pos[1]/1000)*HEIGHT+100*Math.sin(slope))
				main.ctx.lineTo((this.pos[0]/1000)*HEIGHT+90*Math.cos(slope+Math.PI/45),(this.pos[1]/1000)*HEIGHT+90*Math.sin(slope+Math.PI/45))
				main.ctx.strokeStyle = "red"
				main.ctx.stroke()*/

			},
			updatePos: function(){
				this.pos[0] += Math.cos(this.face)*this.speed
				this.pos[1] += Math.sin(this.face)*this.speed
			},
			draw: function(){
				circle((this.pos[0]/1000)*HEIGHT,(this.pos[1]/1000)*HEIGHT,12,'blue')
				main.ctx.beginPath()
				main.ctx.moveTo((this.pos[0]/1000)*HEIGHT+Math.cos(this.face)*24,(this.pos[1]/1000)*HEIGHT+Math.sin(this.face)*22)
				main.ctx.lineTo((this.pos[0]/1000)*HEIGHT+Math.cos(this.face+Math.PI/15)*16,(this.pos[1]/1000)*HEIGHT+Math.sin(this.face+Math.PI/15)*16)
				main.ctx.lineTo((this.pos[0]/1000)*HEIGHT+Math.cos(this.face-Math.PI/15)*16,(this.pos[1]/1000)*HEIGHT+Math.sin(this.face-Math.PI/15)*16)
				main.ctx.closePath()
				main.ctx.strokeStyle = "blue"; main.ctx.stroke();
				main.ctx.beginPath()
				main.ctx.moveTo((this.pos[0]/1000)*HEIGHT+Math.cos(this.steerRot+this.face)*20,(this.pos[1]/1000)*HEIGHT+Math.sin(this.steerRot+this.face)*22)
				main.ctx.lineTo((this.pos[0]/1000)*HEIGHT+Math.cos(this.steerRot+Math.PI/15+this.face)*16,(this.pos[1]/1000)*HEIGHT+Math.sin(this.steerRot+Math.PI/15+this.face)*16)
				main.ctx.lineTo((this.pos[0]/1000)*HEIGHT+Math.cos(this.steerRot-Math.PI/15+this.face)*16,(this.pos[1]/1000)*HEIGHT+Math.sin(this.steerRot-Math.PI/15+this.face)*16)
				main.ctx.closePath()
				main.ctx.strokeStyle = "red"; main.ctx.stroke();
				main.ctx.strokeStyle = "rgba(255,0,0,0.3)"; main.ctx.lineWidth = 4
				main.ctx.strokeRect((this.tPos[0]/1000)*HEIGHT-5,(this.tPos[1]/1000)*HEIGHT-5,10,10)
				main.ctx.strokeStyle = "rgba(255,0,0,0.2)"; main.ctx.lineWidth = 7
				main.ctx.strokeRect((this.tPos[0]/1000)*HEIGHT-5,(this.tPos[1]/1000)*HEIGHT-5,10,10)
				main.ctx.strokeStyle = "rgba(255,0,0,0.1)"; main.ctx.lineWidth = 11
				main.ctx.strokeRect((this.tPos[0]/1000)*HEIGHT-5,(this.tPos[1]/1000)*HEIGHT-5,10,10)
				main.ctx.lineWidth = 1
			}
		}

		function circle(x,y,r,color){
			var cx; var cy = [];
			main.ctx.beginPath()
			for (cx = -r; cx <= r; cx++){
				cy.push(Math.round(Math.sqrt((r**2)-(cx**2))))
			}
			var cind;
			for (cx = cy.length-1; cx > -cy.length; cx--){
				if (cx > 0){
					cind = cy[Math.abs(cx)]
				} else {
					cind = -cy[Math.abs(cx)]
				}
				if (cx == cy.length){ 
					main.ctx.moveTo(x + Math.abs(cx) - r, y + cind)
				} else {
					main.ctx.lineTo(x + Math.abs(cx) - r, y + cind)
				}
			}
			main.ctx.strokeStyle = color
			main.ctx.stroke()
		}

		function createTarget(x,y){
			this.pos = [x,y]/*
			this.updatePos = function(){
				if (!this.caught){
					this.rot = (this.rot+Math.PI/90)%(2*Math.PI)
					this.pos = [500+400*Math.cos(this.rot),500+400*Math.sin(this.rot)]
				}
			}*/
			this.draw = function(){
				main.ctx.strokeStyle = "rgba(255,40,40,0.5)"
				main.ctx.strokeRect((this.pos[0]/1000)*HEIGHT-5,(this.pos[1]/1000)*HEIGHT-5,10,10)
			}
		}

		target = []
		target.push(new createTarget(800,500))
		target.push(new createTarget(300,800))
		target.push(new createTarget(100,200))
		target.push(new createTarget(400,300))
		target.push(new createTarget(700,150))
		target.push(new createTarget(600,400))
		target.push(new createTarget(600,800))
		target.push(new createTarget(200,500))
		target.push(new createTarget(300,700))
		target.push(new createTarget(650,500))
		target.push(new createTarget(100,900))
		target.push(new createTarget(450,450))

		function draw(){
			player.draw()
			target.forEach(function(e1,i1){
				e1.draw()
			})
		}

		function mainloop(){
			main.ctx.clearRect(0,0,WIDTH,HEIGHT)
			player.move()
			//target.updatePos()
			draw();
		}

		main.start()
		player.targetIndex = Math.floor(Math.random()*target.length)

		window.addEventListener('keydown',function(e){
			switch(e.keyCode){
				case 32: clearInterval(main.loop); break;
				case 37: player.steerDirection = -1; break;
				case 39: player.steerDirection = 1; break;
			}
		})

		window.addEventListener('keyup',function(e){
			switch(e.keyCode){
				case 37: player.steerDirection = 0; break;
				case 39: player.steerDirection = 0; break;
			}
		})

		//j7wJUw9Abys4Y8tM

	</script>
</html>